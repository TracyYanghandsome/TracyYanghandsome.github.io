{"meta":{"title":"Tracy's Blog","subtitle":null,"description":"welcome to Tracy's Blog","author":"Tracy","url":"http://yoursite.com"},"pages":[{"title":"all-tags","date":"2017-08-30T08:23:21.000Z","updated":"2017-08-30T08:23:21.000Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""},{"title":"all-categories","date":"2017-08-30T08:22:41.000Z","updated":"2017-08-30T08:22:41.000Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""}],"posts":[{"title":"web自动化测试入坑第一天","slug":"web自动化测试入坑第一天","date":"2017-08-30T09:23:39.000Z","updated":"2017-08-30T09:25:25.000Z","comments":true,"path":"2017/08/30/web自动化测试入坑第一天/","link":"","permalink":"http://yoursite.com/2017/08/30/web自动化测试入坑第一天/","excerpt":"","text":"#####1.为什么要做自动化测试？ 软件测试是保障和提高软件质量的重要手段。软件开发者和使用者必须对软件进行充分的测试，以确保其正常工作。在典型的软件开发项目中，软件测试工作量往往占开发总工作量的40%以上。因此提高软件测试过程的效率至关重要。为了提高测试效率，越来越多的测试工作引入了自动化测试的思想和方法。实践证明，软件自动化测试技术提高了软件测试的速度和效率，节省了软件测试成本，缩短了产品发布周期。同时，自动化测试技术也完成了许多手工测试无法实现的工作。所以采用自动化测试方法和相应的测试框架成为了软件开发组织测试工作的重要支撑手段。 #####2.什么项目适合做自动化测试？首先考考虑产品是否适合做自动化测试。这方法比较普遍的共识是从三个方面进行权衡。 软件需求变动不频繁测试脚本的稳定性决定了自动化测试的维护成本。如果软件需求变动过于频繁，测试人员需要根据变动的需求来更新测试用例以及相关的测试脚本，而脚本的维护本身就是一个代码开发的过程，需要修改、调试，必要的时候还要修改自动化测试的框架，如果所花费的成本不低于利用其节省的测试成本，那么自动化测试便是失败的。项目中的某些模块相对稳定，而某些模块需求变动性很大。我们便可对相对稳定的模块进行自动化测试，而变动较大的仍是用手工测试。 项目周期较长由于自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成。这样的过程本身就是一个测试软件的开发过程，需要较长的时间来完成。如果项目的周期比较短，没有足够的时间去支持这样一个过程，那么自动化测试便成为笑谈 自动化测试脚本可重复使用自动化测试脚本的重复使用要从三个方面来考量，一方面所测试的项目之间是否很大的差异性(如C/S系统和B/S系统的差异);所选择的测试工具是否适应这种差异；最后，测试人员是否有能力开发出适应这种差异的自动化测试框架。#####好了废话不多说，让我们开始动手吧~~######环境搭建系统环境：macOS Sierra 10.12.5语言：python2.7(可使用Java)使用的框架：selenium2.0#####如何使用selenium进行自动化测试1.首先要熟悉selenium API ，API就是selenium 所定义一方法，用于定位，操作页面上的各种元素，这里就不详说了。selenium API文档地址传送门—&gt;http://selenium-python-zh.readthedocs.io/en/latest/waits.html2.使用Xpath定位传送门 –&gt;http://www.runoob.com/xpath/xpath-syntax.html######学习完以上，你可以游刃有余的模拟手工测试来操作页面上的各种元素了。接着你需要做的就是把这些“用例”组织起来，统一来跑就行了。######Example for BaiduSearch:12345678from selenium import webdriver#定义一个全局变量driverdriver = webdriver.Chrome(); #这里我使用的谷歌浏览器。支持IE，Safari，Firefoxdriver.get(&apos;https://www.baidu.com/&apos;) #开启浏览器并跳转到Urldriver.find_element_by_id(&quot;kw&quot;).clear() #在输入之前清空下文本框里的内容driver.find_element_by_id(&quot;kw&quot;).send_keys(&apos;selenium&apos;) #填充文本框文本driver.find_element_by_id(&quot;submit&quot;).click() #点击搜索按钮 这就完成了一个简单的自动化百度搜索了😂，下一篇会介绍如何做一个自动化测试登录。太久没用Markdown了，请无视排版。。。新人第一次写技术文章，请多多指教😄，欢迎大神们一起探讨~~","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/自动化测试/"}]},{"title":"iOS-Skill","slug":"iOS-Skill","date":"2017-08-30T01:52:58.000Z","updated":"2017-08-30T02:20:07.000Z","comments":true,"path":"2017/08/30/iOS-Skill/","link":"","permalink":"http://yoursite.com/2017/08/30/iOS-Skill/","excerpt":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url];","text":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url]; 汉字转码 12NSString *oriString = @\"\\u67aa\\u738b\";NSString *escapedString = [oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 调用电话，短信，邮件 1234[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"mailto:apple@mac.com?Subject=hello\"]];sms://调用短信tel://调用电话itms://打开MobileStore.app 获取版本信息 12UIDevice *myDevice = [UIDevice currentDevice];NSString *systemVersion = myDevice.systemVersion; &gt; iPhone 更改键盘右下角按键的 type 1234567SearchBar *mySearchBar = [[UISearchBar alloc]init];mySearchBar.frame = CGRectMake(0, 0, self.view.bounds.size.width, 44);mySearchBar.placeholder = @\"placeholderString\";mySearchBar.delegate = self;[self.view addSubview:mySearchBar];UITextField *searchField = [[mySearchBar subviews] lastObject];searchField.returnKeyType = UIReturnKeyDone; 给图片增加模糊效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//加模糊效果，image是图片，blur是模糊度+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur &#123; //模糊度, if ((blur &lt; 0.1f) || (blur &gt; 2.0f)) &#123; blur = 0.1f; &#125; //boxSize必须大于0 int boxSize = (int)(blur * 100); boxSize -= (boxSize % 2) + 1; NSLog(@\"boxSize:%i\",boxSize); //图像处理 CGImageRef img = image.CGImage;&gt; //图像缓存,输入缓存，输出缓存 vImage_Buffer inBuffer, outBuffer; vImage_Error error; //像素缓存 void *pixelBuffer;&gt; //数据源提供者，Defines an opaque type that supplies Quartz with data. CGDataProviderRef inProvider = CGImageGetDataProvider(img); // provider’s data. CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);&gt; //宽，高，字节/行，data inBuffer.width = CGImageGetWidth(img); inBuffer.height = CGImageGetHeight(img); inBuffer.rowBytes = CGImageGetBytesPerRow(img); inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);&gt; //像数缓存，字节行*图片高 pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));&gt; outBuffer.data = pixelBuffer; outBuffer.width = CGImageGetWidth(img); outBuffer.height = CGImageGetHeight(img); outBuffer.rowBytes = CGImageGetBytesPerRow(img);&gt; // 第三个中间的缓存区,抗锯齿的效果 void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img)); vImage_Buffer outBuffer2; outBuffer2.data = pixelBuffer2; outBuffer2.width = CGImageGetWidth(img); outBuffer2.height = CGImageGetHeight(img); outBuffer2.rowBytes = CGImageGetBytesPerRow(img);&gt; //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter. error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer2;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;outBuffer2;, &amp;inBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);&gt; if (error) &#123; NSLog(@\"error from convolution %ld\", error); &#125;&gt; // NSLog(@\"字节组成部分：%zu\",CGImageGetBitsPerComponent(img)); //颜色空间DeviceRGB CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();&gt; //用图片创建上下文,CGImageGetBitsPerComponent(img),7,8 CGContextRef ctx = CGBitmapContextCreate( outBuffer.data, outBuffer.width, outBuffer.height, 8, outBuffer.rowBytes, colorSpace, CGImageGetBitmapInfo(image.CGImage));&gt; //根据上下文，处理过的图片，重新组件 CGImageRef imageRef = CGBitmapContextCreateImage (ctx); UIImage *returnImage = [UIImage imageWithCGImage:imageRef];&gt; //clean up CGContextRelease(ctx); CGColorSpaceRelease(colorSpace); free(pixelBuffer); free(pixelBuffer2); CFRelease(inBitmapData); CGImageRelease(imageRef);&gt; return returnImage;&#125; 图片压缩 12345678910111213141516用法：UIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];//压缩图片- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize&#123;// Create a graphics image contextUIGraphicsBeginImageContext(newSize);// Tell the old image to draw in this newcontext, with the desired// new size[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];// Get the new image from the contextUIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();// End the contextUIGraphicsEndImageContext();// Return the new image.return newImage;&#125; 把时间戳转换为时间 1234567891011+ (NSDate *)dateWithTimeIntervalInMilliSecondSince1970:(double)timeIntervalInMilliSecond &#123; NSDate *ret = nil; double timeInterval = timeIntervalInMilliSecond; if(timeIntervalInMilliSecond &gt; 140000000000) &#123; timeInterval = timeIntervalInMilliSecond / 1000; &#125; ret = [NSDate dateWithTimeIntervalSince1970:timeInterval];&gt; return ret;&#125;&gt; 自定义cell中获取不到cell实际大小的办法 12345&gt;-(void)drawRect:(CGRect)rect &#123; // 重写此方法，并在此方法中获取 CGFloat width = self.frame.size.width;&#125;&gt; 长按图标抖动 12345678910111213&gt;-(void)longPress:(UILongPressGestureRecognizer*)longPress&#123; if (longPress.state==UIGestureRecognizerStateBegan) &#123; CAKeyframeAnimation* anim=[CAKeyframeAnimation animation]; anim.keyPath=@\"transform.rotation\"; anim.values=@[@(angelToRandian(-7)),@(angelToRandian(7)),@(angelToRandian(-7))]; anim.repeatCount=MAXFLOAT; anim.duration=0.2; [self.imageView.layer addAnimation:anim forKey:nil]; self.btn.hidden=NO; &#125;&#125;&gt; 两种方法删除NSUserDefaults所有记录 1234567891011121314&gt;//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];&gt;//方法二- (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize];&#125;&gt; 截屏全图 12345678910&gt;- (UIImage *)imageFromView: (UIView *) theView&#123; UIGraphicsBeginImageContext(theView.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [theView.layer renderInContext:context]; UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();&gt; return theImage;&#125;&gt; 去除UIImageView锯齿 12&gt;imageView.layer.shouldRasterize = YES;&gt; 由身份证号码返回性别 12345678910111213141516171819202122232425262728293031&gt;-(NSString *)sexStrFromIdentityCard:(NSString *)numberStr&#123; NSString *result = nil; BOOL isAllNumber = YES;&gt; if([numberStr length]&lt;17) return result;&gt; //**截取第17为性别识别符 NSString *fontNumer = [numberStr substringWithRange:NSMakeRange(16, 1)];&gt; //**检测是否是数字; const char *str = [fontNumer UTF8String]; const char *p = str; while (*p!='\\0') &#123; if(!(*p&gt;='0'&amp;&amp;*p&lt;='9')) isAllNumber = NO; p++; &#125;&gt; if(!isAllNumber) return result;&gt; int sexNumber = [fontNumer integerValue]; if(sexNumber%2==1) result = @\"男\"; else if (sexNumber%2==0) result = @\"女\";&gt; return result; &#125;&gt; 数组随机重新排列 1234567891011121314151617&gt;+ (NSArray *)getRandomWithPosition:(NSInteger)position positionContent:(id)positionContent array:(NSArray *)baseArray &#123; NSMutableArray *resultArray = [NSMutableArray arrayWithCapacity:baseArray.count]; NSMutableArray *tempBaseArray = [NSMutableArray arrayWithArray:baseArray];&gt; while ([tempBaseArray count]) &#123; NSInteger range = [tempBaseArray count]; id string = [tempBaseArray objectAtIndex:arc4random()%range]; [resultArray addObject:string]; [tempBaseArray removeObject:string]; &#125;&gt; NSUInteger index = [resultArray indexOfObject:positionContent]; [resultArray exchangeObjectAtIndex:index withObjectAtIndex:position - 1];&gt; return resultArray;&#125;&gt; 利用陀螺仪实现更真实的微信摇一摇动画 12345678910111213141516171819202122232425&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; application.applicationSupportsShakeToEdit=YES;&#125;&gt;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123; if(motion==UIEventSubtypeMotionShake) &#123; // 真实一点的摇动动画 [self addAnimations]; // 播放声音 AudioServicesPlaySystemSound (soundID); &#125;&#125;&gt;- (void)addAnimations &#123; CABasicAnimation *translation = [CABasicAnimation animationWithKeyPath:@\"transform\"]; translation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; translation.toValue=[NSValue valueWithCATransform3D:CATransform3DMakeRotation(-M_PI_4, 0, 0, 100)]; translation.duration = 0.2; translation.repeatCount = 2; translation.autoreverses = YES;&gt; [shake.layer addAnimation:translation forKey:@\"translation\"];&#125;&gt; 在后台播放音乐 123456789101112131415161718192021&gt;//1. 在Info.plist中，添加\"Required background modes\"键，其值设置是“App plays audio\" //2. 在播放器播放音乐的代码所在处，添加如下两段代码（当然，前提是已经添加了AVFoundation框架）&gt;//添加后台播放代码：AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; &gt; //以及设置app支持接受远程控制事件代码。设置app支持接受远程控制事件，//其实就是在dock中可以显示应用程序图标，同时点击该图片时，打开app。//或者锁屏时，双击home键，屏幕上方出现应用程序播放控制按钮。[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; &gt;//用下列代码播放音乐，测试后台播放// 创建播放器 AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil]; [player prepareToPlay]; [player setVolume:1]; player.numberOfLoops = -1; //设置音乐播放次数 -1为一直循环 [player play]; //播放&gt; 利用富文本改变字体颜色 123456789101112&gt;- (NSMutableAttributedString *)changeTextColor:(NSString *)text needChange:(NSString *)value UIColor:(UIColor *)color&#123;&gt; NSMutableAttributedString *attrstring = [[NSMutableAttributedString alloc] initWithString:text];&gt; //1.设置字体颜色 [attrstring addAttribute:NSForegroundColorAttributeName value:color range:[text rangeOfString:value]];&gt; return attrstring;&#125;&gt; 计算两个日期之间的天数 123456789101112131415&gt;- (NSInteger)calcDaysFromBegin:(NSDate *)beginDate end:(NSDate *)endDate&#123; //创建日期格式化对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];&gt; //取两个日期对象的时间间隔： //这里的NSTimeInterval 并不是对象，是基本型，其实是double类型，是由c定义的:typedef double NSTimeInterval; NSTimeInterval time = [endDate timeIntervalSinceDate:beginDate];&gt; int days = ((int)time) / (3600*24); //int hours=((int)time)%(3600*24)/3600; //NSString *dateContent=[[NSString alloc] initWithFormat:@\"%i天%i小时\",days,hours]; return days;&#125;&gt; 获取上个月或者下个月 +1是下个月 -1是上个月 1234567891011121314&gt;- (NSDate *)getPriousorLaterDateFromDate:(NSDate *)date withMonth:(int)month&#123;&gt; NSDateComponents *comps = [[NSDateComponents alloc] init];&gt; [comps setMonth:month];&gt; NSCalendar *calender = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&gt; NSDate *mDate = [calender dateByAddingComponents:comps toDate:date options:0];&gt; return mDate;&gt; &#125;&gt; 两个时间比较 1234567891011121314151617181920212223&gt;- (int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; // NSLog(@\"date1 : %@, date2 : %@\", oneDay, anotherDay); if (result == NSOrderedDescending) &#123; //NSLog(@\"Date1 is in the future\"); return 1; &#125; else if (result == NSOrderedAscending)&#123; //NSLog(@\"Date1 is in the past\"); return -1; &#125; //NSLog(@\"Both dates are the same\"); return 0;&gt; &#125;&gt; Date 转 String 123456789101112- (NSString *)stringFromDate:(NSDate *)date&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"];&gt; NSString *destDateString = [dateFormatter stringFromDate:date];&gt; return destDateString;&gt; &#125;&gt; String 转Date 123456789101112&gt;- (NSDate *)dateFromString:(NSString *)dateString&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat: @\"yyyy/MM/dd\"];&gt; NSDate *destDate= [dateFormatter dateFromString:dateString];&gt; return destDate;&gt; &#125;&gt; 浮点转百分比 12345678910111213141516- (NSString *)percentage:(NSString *)value&#123;&gt; float _percent = [value floatValue];&gt; CFLocaleRef currentLocale = CFLocaleCopyCurrent();&gt; CFNumberFormatterRef numberFormatter = CFNumberFormatterCreate(NULL, currentLocale, kCFNumberFormatterPercentStyle);&gt; CFNumberRef number = CFNumberCreate(NULL, kCFNumberFloatType, &amp;_percent);&gt; CFStringRef numberString = CFNumberFormatterCreateStringWithNumber(NULL, numberFormatter, number);&gt; return (__bridge NSString * _Nullable)(numberString);&gt; &#125;&gt; 获取当月第一天跟最后一天 12345678910111213141516171819202122232425262728- (NSString *)getMonthBeginAndEndWith:(NSString *)dateStr&#123;&gt; NSDateFormatter *format=[[NSDateFormatter alloc] init]; [format setDateFormat:@\"yyyy/MM/dd\"]; NSDate *newDate=[format dateFromString:dateStr]; double interval = 0; NSDate *beginDate = nil; NSDate *endDate = nil; NSCalendar *calendar = [NSCalendar currentCalendar];&gt; [calendar setFirstWeekday:2];//设定周一为周首日 BOOL ok = [calendar rangeOfUnit:NSMonthCalendarUnit startDate:&amp;beginDate interval:&amp;interval forDate:newDate]; //分别修改为 NSDayCalendarUnit NSWeekCalendarUnit NSYearCalendarUnit if (ok) &#123; endDate = [beginDate dateByAddingTimeInterval:interval-1]; &#125;else &#123; return @\"\"; &#125; NSDateFormatter *myDateFormatter = [[NSDateFormatter alloc] init]; [myDateFormatter setDateFormat:@\"YYYY/MM/dd\"]; //月初 NSString *beginString = [myDateFormatter stringFromDate:beginDate]; //月末 NSString *endString = [myDateFormatter stringFromDate:endDate]; NSString *s = [NSString stringWithFormat:@\"%@-%@\",beginString,endString]; return s;&#125;&gt; UIColor HEX 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;+ (UIColor *)colorWithHexString:(NSString *)color alpha:(CGFloat)alpha&#123; //删除字符串中的空格 NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString]; // String should be 6 or 8 characters if ([cString length] &lt; 6) &#123; return [UIColor clearColor]; &#125; // strip 0X if it appears //如果是0x开头的，那么截取字符串，字符串从索引为2的位置开始，一直到末尾 if ([cString hasPrefix:@\"0X\"]) &#123; cString = [cString substringFromIndex:2]; &#125; //如果是#开头的，那么截取字符串，字符串从索引为1的位置开始，一直到末尾 if ([cString hasPrefix:@\"#\"]) &#123; cString = [cString substringFromIndex:1]; &#125; if ([cString length] != 6) &#123; return [UIColor clearColor]; &#125;&gt; // Separate into r, g, b substrings NSRange range; range.location = 0; range.length = 2; //r NSString *rString = [cString substringWithRange:range]; //g range.location = 2; NSString *gString = [cString substringWithRange:range]; //b range.location = 4; NSString *bString = [cString substringWithRange:range];&gt; // Scan values unsigned int r, g, b; [[NSScanner scannerWithString:rString] scanHexInt:&amp;r]; [[NSScanner scannerWithString:gString] scanHexInt:&amp;g]; [[NSScanner scannerWithString:bString] scanHexInt:&amp;b]; return [UIColor colorWithRed:((float)r / 255.0f) green:((float)g / 255.0f) blue:((float)b / 255.0f) alpha:alpha];&#125;&gt; ###Objective-C 内存管理 一个对象可以有一个或多个拥有者 当它一个拥有者都没有的时候，它就会被回收 如果想保留一个对象不被回收，你就必须成为它的拥有者 ###关键字 alloc 为对象分配内存，计数设为1，并返回此对象。 copy 复制一个对象，此对象计数为1，返回此对象。你将成为此克隆对象的拥有者。 retain 对象计数+1，并成为次对象的拥有者。 release 对象计数-1，并丢掉此对象。 autorelease 在未来的 某一个时刻，对象计数-1。并在未来的某个时间放弃此对象。 ###原则 一个代码块内要确保copy，alloc 和 retain 的使用数量与 release 和 autorelease 的数量相等。 在使用以 alloc 或 new 开头或包含 copy 的方法，或 retain 一个对象时，你将会编程它的拥有者。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 实现 dealloc 方法，这是系统当 retain -&gt; 0 的时候，自动调用的。手动调用会引起 retain count 计数错误（多一次的 release）。 ###tableView性能优化 ####cell的循环利用方式112345678910- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @\"cell\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:ID]; &#125; cell.textLabel.text = @\"\"; return cell;&#125; ####cell的循环利用方式2-注册12345678910111213141516171819static NSString *ID = @\"cell\";- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.tableview.dataSource = self; self.tableview.delegate = self; [self.tableview registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"cell\"];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; cell.textLabel.text = @\"\"; return cell;&#125; ###自定义cell ####等高cell1234567-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; return cell.height;&#125; ####非等高cell123456789101112131415161718192021- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; self.heights[@(indexPath.row)] = @(cell.height); // 字典里面是对象 return cell;&#125;// 返回估计高度,非常重要，调节cellforRow和heightForRow的调用方法- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath)indexPath&#123; return 200;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; // 将上面的高度存起来，拿到这里使用 return [self.heights[@(indexPath.row)] doubleValue];&#125; ###设置UITableView分割线距左边的间距1234567-(void)viewDidLoad&#123;[super viewDidLoad];[self.tableView setSeparatorInset:UIEdgeInsetsZero];[self.tableView setLayoutMargins:UIEdgeInsetsZero];&#125; ####在cell将要显示出来的方法中执行下面的代码12345-(void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; [cell setSeparatorInset:UIEdgeInsetsZero]; [cell setLayoutMargins:UIEdgeInsetsZero];&#125; ###iOS隐藏导航栏正确做法 #####以往我们隐藏导航栏都是这样做：12345678- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; #####但是往往这样 会遇到一些奇怪的 bug ，想来想去 我想到这样做可能要更好一点:123456789- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController.view sendSubviewToBack:self.navigationController.navigationBar];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController.view bringSubviewToFront:self.navigationController.navigationBar];&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-29T06:34:53.000Z","updated":"2017-08-30T02:21:02.000Z","comments":true,"path":"2017/08/29/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}