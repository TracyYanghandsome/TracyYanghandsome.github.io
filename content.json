{"meta":{"title":"Trevor's Blog","subtitle":null,"description":"welcome to Trevor's Blog","author":"Trevor","url":"http://yoursite.com"},"pages":[{"title":"all-categories","date":"2017-08-30T08:22:41.000Z","updated":"2017-08-30T08:22:41.000Z","comments":false,"path":"all-categories/index.html","permalink":"http://yoursite.com/all-categories/index.html","excerpt":"","text":""},{"title":"all-tags","date":"2017-08-30T08:23:21.000Z","updated":"2017-08-30T08:23:21.000Z","comments":false,"path":"all-tags/index.html","permalink":"http://yoursite.com/all-tags/index.html","excerpt":"","text":""}],"posts":[{"title":"让Curl在Mac上支持HTTPS","slug":"让Curl在Mac支持HTTPS","date":"2017-09-30T00:52:58.000Z","updated":"2018-02-05T07:39:52.492Z","comments":true,"path":"2017/09/30/让Curl在Mac支持HTTPS/","link":"","permalink":"http://yoursite.com/2017/09/30/让Curl在Mac支持HTTPS/","excerpt":"","text":"curl默认安装的话，是不支持https，当你在使用libcurl去访问https时，就会报以下的错误 EDBBC8D8-A1AB-4B35-A6AF-2A3D6896F6BF.png 如果curl要支持https，就必须先安装openssl。因为Mac是自带openssl的。 91C08D47-AC04-46A9-B7F3-BDB90A72864F.png 所以我们只要cd到curl-7.56.1根目录下执行一下命令开启SSL:1./configure --with-darwinssl 9821D406-874A-4FDE-B44D-E5D76CB028A6.png 接下来会输出很多，这里我们不用管，看最后一条Message出现HTTPS就OK了。 ######Protocols: DICT FILE FTP FTPS GOPHER HTTP HTTPS IMAP IMAPS LDAP LDAPS POP3 POP3S RTSP SMB SMBS SMTP SMTPS TELNET TFTP然后重新执行:1sudo make install 检查是否成功: 9CFE5928-64AF-483E-BF32-972C33208A91.png","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"Pip常用命令","slug":"Pip常用命令","date":"2017-09-03T00:22:18.000Z","updated":"2018-02-05T07:44:10.024Z","comments":true,"path":"2017/09/03/Pip常用命令/","link":"","permalink":"http://yoursite.com/2017/09/03/Pip常用命令/","excerpt":"","text":"#####列出已安装的包list``` or ```pip freeze```1#####导出requirements.txt pip freeze &gt; &lt;目录&gt;/requirements.txt123#####安装包######在线安装```pip install &lt;包名&gt;``` or ```pip install -r requirements.txt 12345678# 安装1.9版本的djangopip install django==1.9# 安装版本号大于1.9的django，注意有引号pip install &quot;django&gt;1.9&quot;pip install &quot;django&gt;=1.9&quot;pip install &quot;django&lt;1.9&quot;pip install &quot;django&lt;=1.9&quot;pip install &quot;django&gt;&lt;1.9&quot; requirements.txt内容格式为:12345678APScheduler==2.1.2Django==1.5.4MySQL-Connector-Python==2.0.1MySQL-python==1.2.3PIL==1.1.7South==1.0.2django-grappelli==2.6.3django-pagination==1.0.7 ######安装本地安装包install /``` or ```pip install --use-wheel --no-index --find-links=wheelhouse/ ```12可简写为: pip install –no-index -f=&lt;目录&gt;/ &lt;包名&gt;12######卸载包```pip uninstall &lt;包名&gt;``` or ```pip uninstall -r requirements.txt ######升级包1pip install -U &lt;包名&gt; ######升级pip1pip install -U pip ######显示包所在的目录1pip show -f &lt;包名&gt; ######搜索包1pip search &lt;搜索关键字&gt; ######查询可升级的包1pip list -o ######下载包而不安装install -d ``` or ```pip install -d -r requirements.txt```12######打包 pip wheel &lt;包名&gt;12345678#####更换国内pypi镜像#####国内pypi镜像豆瓣：[https://pypi.douban.com/simple](https://pypi.douban.com/simple)中国科学技术大学：[https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/](https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/)清华大学TUNA：[https://pypi.tuna.tsinghua.edu.cn/simple](https://pypi.tuna.tsinghua.edu.cn/simple)######指定单次安装源 pip install &lt;包名&gt; -i http://pypi.v2ex.com/simple123######指定全局安装源在unix和macos，配置文件为：$HOME/.pip/pip.conf在windows上，配置文件为：%HOME%\\pip\\pip.ini [global]timeout = 6000index-url = http://pypi.douban.com/simple``` ######参考资料pip documentation","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"web自动化测试入坑第二天","slug":"web自动化测试入坑第二天","date":"2017-08-31T02:41:17.000Z","updated":"2017-08-31T02:49:21.000Z","comments":true,"path":"2017/08/31/web自动化测试入坑第二天/","link":"","permalink":"http://yoursite.com/2017/08/31/web自动化测试入坑第二天/","excerpt":"","text":"看完上一篇文章，传送门—&gt;http://www.jianshu.com/p/1c57ba4b8740。我想大家都应该对自动化测试有个基本了解了，接下来写个自动测试登录吧~~在写登录之前，我们先来了解一下一个登录流程是什么样的。这里简单的画了一下流程图 登录流程.png 了解完整个流程之后，我们先不忙于去怎么用代码实现，因为在实现自动登录的时候我们会遇到一个问题，就是验证码这块应该怎么去解决。 #####如何解决在登录时验证码的问题1.绕过验证码进行登录，跟后端商量测试的时候把验证码验证关闭就好了😂，这是最简单的方法也是比较好用的方法了~2.识别验证码。这里我用的pytesseract做的验证码识别，具体看下面代码12345678910111213141516171819202122232425from selenium import webdriverimport os,time,sysfrom PIL import Imagefrom pytesseract import *driver = webdriver.Chrome()def getAuthCode(ulr): driver.get(ulr); time.sleep(0.5); driver.save_screenshot(&quot;captcha.jpg&quot;) # 截屏，并保存图片 cleanImage(&quot;captcha.jpg&quot;) im = Image.open(&apos;captcha1.jpg&apos;) code = pytesseract.image_to_string(im) if len(code) == 4: return code else: return Falsedef cleanImage(imagePath): image = Image.open(imagePath); #打开图片 print image.format, image.size, image.mode box = (1000, 665, 1100, 695) #谷歌浏览器解析自带黑色背景,裁剪出验证码 region = image.crop(box) region.convert(&apos;RGB&apos;).save(&apos;/Users/mac/Desktop/captcha1.jpg&apos;) 这里的思路是先找到验证码的地址，然后截图保存图片，再打开图片进行裁剪，再利用pytesseract进行识别。 ######这种方式基本上能识别简单的验证码，稍微复杂点的就不行了，而且正确率不是特别高，由于时间问题，我这里并没有针对图片识别进行更多的投入，只是花了点时间在Google跟Baidu上搜了下资料，然后跟朋友探讨了下，pytesseract已经过时了，如果真的想做图片识别的话，可以研究下CNN，利用卷积神经网络搞的，等有时间的时候我会去研究下，研究完后会专门写一篇关于图像识别的文章，这里就不多提了。(有兴趣的朋友可以一起交流~) ######所以最终我选的方式是跟后端商量，在测试的时候把验证码关闭了😂。好了，进入今天的正题~首先看下我要做测试的登录页： 登录页面.png 123456789101112131415161718192021222324252627282930313233343536from selenium import webdriver #导入webdriver#定义一个全局变量driverdriver = webdriver.Chrome(); #定义一个全局登录页urlloginPage = &quot;http://xxxxxx/Login.aspx&quot;#定义一个登录方法并传入描述，账户，密码def testLogin(des, userName,password,): print des,&apos;用户名:&apos;,userName,&apos;密码:&apos;,password; driver.get(loginPage) #开启浏览器并跳转到Url driver.find_element_by_id(&quot;username&quot;).clear() #在输入用户名之前清空下文本框里的内容 driver.find_element_by_id(&quot;username&quot;).send_keys(userName) #填充用户名文本框文本 driver.find_element_by_id(&quot;pwd&quot;).clear() driver.find_element_by_id(&quot;pwd&quot;).send_keys(password) driver.find_element_by_id(&quot;loginbtn&quot;).click() #点击登录按钮 #这里如果不加try except的话，正常登录会crash，因为正常登录是不弹窗的，只有在登录失败的时候，才会弹窗提示。 try: if driver.switch_to_alert():#拦截弹窗 driver.switch_to_alert().accept(); #关闭弹窗并确认 driver.find_element_by_id(&quot;username&quot;).clear() #清空用户名 driver.find_element_by_id(&quot;pwd&quot;).clear() #清空密码 print driver.switch_to_alert().text #打印弹窗内容 except Exception,e: print eif __name__ ==&apos;__main__&apos;: testLogin(&apos;测试未输入用户名&apos;, &apos;&apos;, &apos;&apos;) testLogin(&apos;测试未输入密码&apos;, &apos;qd_test_001&apos;, &apos;&apos;) testLogin(&apos;测试帐户不存在&apos;, &apos;21121&apos;, &apos;xxxxxxx&apos;) testLogin(&apos;测试成功登录&apos;, &apos;sa&apos;, &apos;123456&apos;)-------------------------------打印结果------------------------测试未输入用户名 用户名: 密码: 测试未输入密码 用户名: qd_test_001 密码: 测试帐户不存在 用户名: 21121 密码: xxxxxxx测试成功登录 用户名: sa 密码: 123456 ######这样就完成了所有登录的自动化测试了,自从有了自动化测试再也不用做一些枯燥乏味的事情了，而且测试时间比以前大大提升了很多!下一篇讲下如何加入测试用例并生成报告。欢迎广大的python爱好者一起交流~ 新手上路第二天，请多多指教😁😁😁。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/自动化测试/"}]},{"title":"web自动化测试入坑第一天","slug":"web自动化测试入坑第一天","date":"2017-08-30T09:23:39.000Z","updated":"2017-08-30T09:27:22.000Z","comments":true,"path":"2017/08/30/web自动化测试入坑第一天/","link":"","permalink":"http://yoursite.com/2017/08/30/web自动化测试入坑第一天/","excerpt":"","text":"#####1.为什么要做自动化测试？ 软件测试是保障和提高软件质量的重要手段。软件开发者和使用者必须对软件进行充分的测试，以确保其正常工作。在典型的软件开发项目中，软件测试工作量往往占开发总工作量的40%以上。因此提高软件测试过程的效率至关重要。为了提高测试效率，越来越多的测试工作引入了自动化测试的思想和方法。实践证明，软件自动化测试技术提高了软件测试的速度和效率，节省了软件测试成本，缩短了产品发布周期。同时，自动化测试技术也完成了许多手工测试无法实现的工作。所以采用自动化测试方法和相应的测试框架成为了软件开发组织测试工作的重要支撑手段。 #####2.什么项目适合做自动化测试？首先考考虑产品是否适合做自动化测试。这方法比较普遍的共识是从三个方面进行权衡。 软件需求变动不频繁测试脚本的稳定性决定了自动化测试的维护成本。如果软件需求变动过于频繁，测试人员需要根据变动的需求来更新测试用例以及相关的测试脚本，而脚本的维护本身就是一个代码开发的过程，需要修改、调试，必要的时候还要修改自动化测试的框架，如果所花费的成本不低于利用其节省的测试成本，那么自动化测试便是失败的。项目中的某些模块相对稳定，而某些模块需求变动性很大。我们便可对相对稳定的模块进行自动化测试，而变动较大的仍是用手工测试。 项目周期较长由于自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成。这样的过程本身就是一个测试软件的开发过程，需要较长的时间来完成。如果项目的周期比较短，没有足够的时间去支持这样一个过程，那么自动化测试便成为笑谈 自动化测试脚本可重复使用自动化测试脚本的重复使用要从三个方面来考量，一方面所测试的项目之间是否很大的差异性(如C/S系统和B/S系统的差异);所选择的测试工具是否适应这种差异；最后，测试人员是否有能力开发出适应这种差异的自动化测试框架。#####好了废话不多说，让我们开始动手吧~~######环境搭建系统环境：macOS Sierra 10.12.5语言：python2.7(可使用Java)使用的框架：selenium2.0#####如何使用selenium进行自动化测试1.首先要熟悉selenium API ，API就是selenium 所定义一方法，用于定位，操作页面上的各种元素，这里就不详说了。selenium API文档地址传送门—&gt;http://selenium-python-zh.readthedocs.io/en/latest/waits.html2.使用Xpath定位传送门 –&gt;http://www.runoob.com/xpath/xpath-syntax.html######学习完以上，你可以游刃有余的模拟手工测试来操作页面上的各种元素了。接着你需要做的就是把这些“用例”组织起来，统一来跑就行了。######Example for BaiduSearch:12345678from selenium import webdriver#定义一个全局变量driverdriver = webdriver.Chrome(); #这里我使用的谷歌浏览器。支持IE，Safari，Firefoxdriver.get(&apos;https://www.baidu.com/&apos;) #开启浏览器并跳转到Urldriver.find_element_by_id(&quot;kw&quot;).clear() #在输入之前清空下文本框里的内容driver.find_element_by_id(&quot;kw&quot;).send_keys(&apos;selenium&apos;) #填充文本框文本driver.find_element_by_id(&quot;submit&quot;).click() #点击搜索按钮 这就完成了一个简单的自动化百度搜索了😂，下一篇会介绍如何做一个自动化测试登录。太久没用Markdown了，请无视排版。。。新人第一次写技术文章，请多多指教😄，欢迎大神们一起探讨~~","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/自动化测试/"}]},{"title":"iOS-Skill","slug":"iOS-Skill","date":"2017-08-30T01:52:58.000Z","updated":"2017-08-30T02:20:07.000Z","comments":true,"path":"2017/08/30/iOS-Skill/","link":"","permalink":"http://yoursite.com/2017/08/30/iOS-Skill/","excerpt":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url];","text":"#####iOS开发过程中一些小问题小技巧，代码片段。 利用Safari打开一个链接 12NSURL *url = [NSURL URLWithString:@\"http://baidu.com\"];[[UIApplication sharedApplication] openURL:url]; 汉字转码 12NSString *oriString = @\"\\u67aa\\u738b\";NSString *escapedString = [oriString stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; 调用电话，短信，邮件 1234[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@\"mailto:apple@mac.com?Subject=hello\"]];sms://调用短信tel://调用电话itms://打开MobileStore.app 获取版本信息 12UIDevice *myDevice = [UIDevice currentDevice];NSString *systemVersion = myDevice.systemVersion; &gt; iPhone 更改键盘右下角按键的 type 1234567SearchBar *mySearchBar = [[UISearchBar alloc]init];mySearchBar.frame = CGRectMake(0, 0, self.view.bounds.size.width, 44);mySearchBar.placeholder = @\"placeholderString\";mySearchBar.delegate = self;[self.view addSubview:mySearchBar];UITextField *searchField = [[mySearchBar subviews] lastObject];searchField.returnKeyType = UIReturnKeyDone; 给图片增加模糊效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//加模糊效果，image是图片，blur是模糊度+ (UIImage *)blurryImage:(UIImage *)image withBlurLevel:(CGFloat)blur &#123; //模糊度, if ((blur &lt; 0.1f) || (blur &gt; 2.0f)) &#123; blur = 0.1f; &#125; //boxSize必须大于0 int boxSize = (int)(blur * 100); boxSize -= (boxSize % 2) + 1; NSLog(@\"boxSize:%i\",boxSize); //图像处理 CGImageRef img = image.CGImage;&gt; //图像缓存,输入缓存，输出缓存 vImage_Buffer inBuffer, outBuffer; vImage_Error error; //像素缓存 void *pixelBuffer;&gt; //数据源提供者，Defines an opaque type that supplies Quartz with data. CGDataProviderRef inProvider = CGImageGetDataProvider(img); // provider’s data. CFDataRef inBitmapData = CGDataProviderCopyData(inProvider);&gt; //宽，高，字节/行，data inBuffer.width = CGImageGetWidth(img); inBuffer.height = CGImageGetHeight(img); inBuffer.rowBytes = CGImageGetBytesPerRow(img); inBuffer.data = (void*)CFDataGetBytePtr(inBitmapData);&gt; //像数缓存，字节行*图片高 pixelBuffer = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img));&gt; outBuffer.data = pixelBuffer; outBuffer.width = CGImageGetWidth(img); outBuffer.height = CGImageGetHeight(img); outBuffer.rowBytes = CGImageGetBytesPerRow(img);&gt; // 第三个中间的缓存区,抗锯齿的效果 void *pixelBuffer2 = malloc(CGImageGetBytesPerRow(img) * CGImageGetHeight(img)); vImage_Buffer outBuffer2; outBuffer2.data = pixelBuffer2; outBuffer2.width = CGImageGetWidth(img); outBuffer2.height = CGImageGetHeight(img); outBuffer2.rowBytes = CGImageGetBytesPerRow(img);&gt; //Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter. error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer2;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;outBuffer2;, &amp;inBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend); error = vImageBoxConvolve_ARGB8888(&amp;inBuffer;, &amp;outBuffer;, NULL, 0, 0, boxSize, boxSize, NULL, kvImageEdgeExtend);&gt; if (error) &#123; NSLog(@\"error from convolution %ld\", error); &#125;&gt; // NSLog(@\"字节组成部分：%zu\",CGImageGetBitsPerComponent(img)); //颜色空间DeviceRGB CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();&gt; //用图片创建上下文,CGImageGetBitsPerComponent(img),7,8 CGContextRef ctx = CGBitmapContextCreate( outBuffer.data, outBuffer.width, outBuffer.height, 8, outBuffer.rowBytes, colorSpace, CGImageGetBitmapInfo(image.CGImage));&gt; //根据上下文，处理过的图片，重新组件 CGImageRef imageRef = CGBitmapContextCreateImage (ctx); UIImage *returnImage = [UIImage imageWithCGImage:imageRef];&gt; //clean up CGContextRelease(ctx); CGColorSpaceRelease(colorSpace); free(pixelBuffer); free(pixelBuffer2); CFRelease(inBitmapData); CGImageRelease(imageRef);&gt; return returnImage;&#125; 图片压缩 12345678910111213141516用法：UIImage *yourImage= [self imageWithImageSimple:image scaledToSize:CGSizeMake(210.0, 210.0)];//压缩图片- (UIImage*)imageWithImageSimple:(UIImage*)image scaledToSize:(CGSize)newSize&#123;// Create a graphics image contextUIGraphicsBeginImageContext(newSize);// Tell the old image to draw in this newcontext, with the desired// new size[image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];// Get the new image from the contextUIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();// End the contextUIGraphicsEndImageContext();// Return the new image.return newImage;&#125; 把时间戳转换为时间 1234567891011+ (NSDate *)dateWithTimeIntervalInMilliSecondSince1970:(double)timeIntervalInMilliSecond &#123; NSDate *ret = nil; double timeInterval = timeIntervalInMilliSecond; if(timeIntervalInMilliSecond &gt; 140000000000) &#123; timeInterval = timeIntervalInMilliSecond / 1000; &#125; ret = [NSDate dateWithTimeIntervalSince1970:timeInterval];&gt; return ret;&#125;&gt; 自定义cell中获取不到cell实际大小的办法 12345&gt;-(void)drawRect:(CGRect)rect &#123; // 重写此方法，并在此方法中获取 CGFloat width = self.frame.size.width;&#125;&gt; 长按图标抖动 12345678910111213&gt;-(void)longPress:(UILongPressGestureRecognizer*)longPress&#123; if (longPress.state==UIGestureRecognizerStateBegan) &#123; CAKeyframeAnimation* anim=[CAKeyframeAnimation animation]; anim.keyPath=@\"transform.rotation\"; anim.values=@[@(angelToRandian(-7)),@(angelToRandian(7)),@(angelToRandian(-7))]; anim.repeatCount=MAXFLOAT; anim.duration=0.2; [self.imageView.layer addAnimation:anim forKey:nil]; self.btn.hidden=NO; &#125;&#125;&gt; 两种方法删除NSUserDefaults所有记录 1234567891011121314&gt;//方法一NSString *appDomain = [[NSBundle mainBundle] bundleIdentifier];[[NSUserDefaults standardUserDefaults] removePersistentDomainForName:appDomain];&gt;//方法二- (void)resetDefaults &#123; NSUserDefaults * defs = [NSUserDefaults standardUserDefaults]; NSDictionary * dict = [defs dictionaryRepresentation]; for (id key in dict) &#123; [defs removeObjectForKey:key]; &#125; [defs synchronize];&#125;&gt; 截屏全图 12345678910&gt;- (UIImage *)imageFromView: (UIView *) theView&#123; UIGraphicsBeginImageContext(theView.frame.size); CGContextRef context = UIGraphicsGetCurrentContext(); [theView.layer renderInContext:context]; UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext();&gt; return theImage;&#125;&gt; 去除UIImageView锯齿 12&gt;imageView.layer.shouldRasterize = YES;&gt; 由身份证号码返回性别 12345678910111213141516171819202122232425262728293031&gt;-(NSString *)sexStrFromIdentityCard:(NSString *)numberStr&#123; NSString *result = nil; BOOL isAllNumber = YES;&gt; if([numberStr length]&lt;17) return result;&gt; //**截取第17为性别识别符 NSString *fontNumer = [numberStr substringWithRange:NSMakeRange(16, 1)];&gt; //**检测是否是数字; const char *str = [fontNumer UTF8String]; const char *p = str; while (*p!='\\0') &#123; if(!(*p&gt;='0'&amp;&amp;*p&lt;='9')) isAllNumber = NO; p++; &#125;&gt; if(!isAllNumber) return result;&gt; int sexNumber = [fontNumer integerValue]; if(sexNumber%2==1) result = @\"男\"; else if (sexNumber%2==0) result = @\"女\";&gt; return result; &#125;&gt; 数组随机重新排列 1234567891011121314151617&gt;+ (NSArray *)getRandomWithPosition:(NSInteger)position positionContent:(id)positionContent array:(NSArray *)baseArray &#123; NSMutableArray *resultArray = [NSMutableArray arrayWithCapacity:baseArray.count]; NSMutableArray *tempBaseArray = [NSMutableArray arrayWithArray:baseArray];&gt; while ([tempBaseArray count]) &#123; NSInteger range = [tempBaseArray count]; id string = [tempBaseArray objectAtIndex:arc4random()%range]; [resultArray addObject:string]; [tempBaseArray removeObject:string]; &#125;&gt; NSUInteger index = [resultArray indexOfObject:positionContent]; [resultArray exchangeObjectAtIndex:index withObjectAtIndex:position - 1];&gt; return resultArray;&#125;&gt; 利用陀螺仪实现更真实的微信摇一摇动画 12345678910111213141516171819202122232425&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; application.applicationSupportsShakeToEdit=YES;&#125;&gt;-(void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event &#123; if(motion==UIEventSubtypeMotionShake) &#123; // 真实一点的摇动动画 [self addAnimations]; // 播放声音 AudioServicesPlaySystemSound (soundID); &#125;&#125;&gt;- (void)addAnimations &#123; CABasicAnimation *translation = [CABasicAnimation animationWithKeyPath:@\"transform\"]; translation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]; translation.toValue=[NSValue valueWithCATransform3D:CATransform3DMakeRotation(-M_PI_4, 0, 0, 100)]; translation.duration = 0.2; translation.repeatCount = 2; translation.autoreverses = YES;&gt; [shake.layer addAnimation:translation forKey:@\"translation\"];&#125;&gt; 在后台播放音乐 123456789101112131415161718192021&gt;//1. 在Info.plist中，添加\"Required background modes\"键，其值设置是“App plays audio\" //2. 在播放器播放音乐的代码所在处，添加如下两段代码（当然，前提是已经添加了AVFoundation框架）&gt;//添加后台播放代码：AVAudioSession *session = [AVAudioSession sharedInstance]; [session setActive:YES error:nil]; [session setCategory:AVAudioSessionCategoryPlayback error:nil]; &gt; //以及设置app支持接受远程控制事件代码。设置app支持接受远程控制事件，//其实就是在dock中可以显示应用程序图标，同时点击该图片时，打开app。//或者锁屏时，双击home键，屏幕上方出现应用程序播放控制按钮。[[UIApplication sharedApplication] beginReceivingRemoteControlEvents]; &gt;//用下列代码播放音乐，测试后台播放// 创建播放器 AVAudioPlayer *player = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:nil]; [player prepareToPlay]; [player setVolume:1]; player.numberOfLoops = -1; //设置音乐播放次数 -1为一直循环 [player play]; //播放&gt; 利用富文本改变字体颜色 123456789101112&gt;- (NSMutableAttributedString *)changeTextColor:(NSString *)text needChange:(NSString *)value UIColor:(UIColor *)color&#123;&gt; NSMutableAttributedString *attrstring = [[NSMutableAttributedString alloc] initWithString:text];&gt; //1.设置字体颜色 [attrstring addAttribute:NSForegroundColorAttributeName value:color range:[text rangeOfString:value]];&gt; return attrstring;&#125;&gt; 计算两个日期之间的天数 123456789101112131415&gt;- (NSInteger)calcDaysFromBegin:(NSDate *)beginDate end:(NSDate *)endDate&#123; //创建日期格式化对象 NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm\"];&gt; //取两个日期对象的时间间隔： //这里的NSTimeInterval 并不是对象，是基本型，其实是double类型，是由c定义的:typedef double NSTimeInterval; NSTimeInterval time = [endDate timeIntervalSinceDate:beginDate];&gt; int days = ((int)time) / (3600*24); //int hours=((int)time)%(3600*24)/3600; //NSString *dateContent=[[NSString alloc] initWithFormat:@\"%i天%i小时\",days,hours]; return days;&#125;&gt; 获取上个月或者下个月 +1是下个月 -1是上个月 1234567891011121314&gt;- (NSDate *)getPriousorLaterDateFromDate:(NSDate *)date withMonth:(int)month&#123;&gt; NSDateComponents *comps = [[NSDateComponents alloc] init];&gt; [comps setMonth:month];&gt; NSCalendar *calender = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&gt; NSDate *mDate = [calender dateByAddingComponents:comps toDate:date options:0];&gt; return mDate;&gt; &#125;&gt; 两个时间比较 1234567891011121314151617181920212223&gt;- (int)compareOneDay:(NSDate *)oneDay withAnotherDay:(NSDate *)anotherDay&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"]; NSString *oneDayStr = [dateFormatter stringFromDate:oneDay]; NSString *anotherDayStr = [dateFormatter stringFromDate:anotherDay]; NSDate *dateA = [dateFormatter dateFromString:oneDayStr]; NSDate *dateB = [dateFormatter dateFromString:anotherDayStr]; NSComparisonResult result = [dateA compare:dateB]; // NSLog(@\"date1 : %@, date2 : %@\", oneDay, anotherDay); if (result == NSOrderedDescending) &#123; //NSLog(@\"Date1 is in the future\"); return 1; &#125; else if (result == NSOrderedAscending)&#123; //NSLog(@\"Date1 is in the past\"); return -1; &#125; //NSLog(@\"Both dates are the same\"); return 0;&gt; &#125;&gt; Date 转 String 123456789101112- (NSString *)stringFromDate:(NSDate *)date&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat:@\"yyyy/MM/dd\"];&gt; NSString *destDateString = [dateFormatter stringFromDate:date];&gt; return destDateString;&gt; &#125;&gt; String 转Date 123456789101112&gt;- (NSDate *)dateFromString:(NSString *)dateString&#123;&gt; NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];&gt; [dateFormatter setDateFormat: @\"yyyy/MM/dd\"];&gt; NSDate *destDate= [dateFormatter dateFromString:dateString];&gt; return destDate;&gt; &#125;&gt; 浮点转百分比 12345678910111213141516- (NSString *)percentage:(NSString *)value&#123;&gt; float _percent = [value floatValue];&gt; CFLocaleRef currentLocale = CFLocaleCopyCurrent();&gt; CFNumberFormatterRef numberFormatter = CFNumberFormatterCreate(NULL, currentLocale, kCFNumberFormatterPercentStyle);&gt; CFNumberRef number = CFNumberCreate(NULL, kCFNumberFloatType, &amp;_percent);&gt; CFStringRef numberString = CFNumberFormatterCreateStringWithNumber(NULL, numberFormatter, number);&gt; return (__bridge NSString * _Nullable)(numberString);&gt; &#125;&gt; 获取当月第一天跟最后一天 12345678910111213141516171819202122232425262728- (NSString *)getMonthBeginAndEndWith:(NSString *)dateStr&#123;&gt; NSDateFormatter *format=[[NSDateFormatter alloc] init]; [format setDateFormat:@\"yyyy/MM/dd\"]; NSDate *newDate=[format dateFromString:dateStr]; double interval = 0; NSDate *beginDate = nil; NSDate *endDate = nil; NSCalendar *calendar = [NSCalendar currentCalendar];&gt; [calendar setFirstWeekday:2];//设定周一为周首日 BOOL ok = [calendar rangeOfUnit:NSMonthCalendarUnit startDate:&amp;beginDate interval:&amp;interval forDate:newDate]; //分别修改为 NSDayCalendarUnit NSWeekCalendarUnit NSYearCalendarUnit if (ok) &#123; endDate = [beginDate dateByAddingTimeInterval:interval-1]; &#125;else &#123; return @\"\"; &#125; NSDateFormatter *myDateFormatter = [[NSDateFormatter alloc] init]; [myDateFormatter setDateFormat:@\"YYYY/MM/dd\"]; //月初 NSString *beginString = [myDateFormatter stringFromDate:beginDate]; //月末 NSString *endString = [myDateFormatter stringFromDate:endDate]; NSString *s = [NSString stringWithFormat:@\"%@-%@\",beginString,endString]; return s;&#125;&gt; UIColor HEX 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;+ (UIColor *)colorWithHexString:(NSString *)color alpha:(CGFloat)alpha&#123; //删除字符串中的空格 NSString *cString = [[color stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString]; // String should be 6 or 8 characters if ([cString length] &lt; 6) &#123; return [UIColor clearColor]; &#125; // strip 0X if it appears //如果是0x开头的，那么截取字符串，字符串从索引为2的位置开始，一直到末尾 if ([cString hasPrefix:@\"0X\"]) &#123; cString = [cString substringFromIndex:2]; &#125; //如果是#开头的，那么截取字符串，字符串从索引为1的位置开始，一直到末尾 if ([cString hasPrefix:@\"#\"]) &#123; cString = [cString substringFromIndex:1]; &#125; if ([cString length] != 6) &#123; return [UIColor clearColor]; &#125;&gt; // Separate into r, g, b substrings NSRange range; range.location = 0; range.length = 2; //r NSString *rString = [cString substringWithRange:range]; //g range.location = 2; NSString *gString = [cString substringWithRange:range]; //b range.location = 4; NSString *bString = [cString substringWithRange:range];&gt; // Scan values unsigned int r, g, b; [[NSScanner scannerWithString:rString] scanHexInt:&amp;r]; [[NSScanner scannerWithString:gString] scanHexInt:&amp;g]; [[NSScanner scannerWithString:bString] scanHexInt:&amp;b]; return [UIColor colorWithRed:((float)r / 255.0f) green:((float)g / 255.0f) blue:((float)b / 255.0f) alpha:alpha];&#125;&gt; ###Objective-C 内存管理 一个对象可以有一个或多个拥有者 当它一个拥有者都没有的时候，它就会被回收 如果想保留一个对象不被回收，你就必须成为它的拥有者 ###关键字 alloc 为对象分配内存，计数设为1，并返回此对象。 copy 复制一个对象，此对象计数为1，返回此对象。你将成为此克隆对象的拥有者。 retain 对象计数+1，并成为次对象的拥有者。 release 对象计数-1，并丢掉此对象。 autorelease 在未来的 某一个时刻，对象计数-1。并在未来的某个时间放弃此对象。 ###原则 一个代码块内要确保copy，alloc 和 retain 的使用数量与 release 和 autorelease 的数量相等。 在使用以 alloc 或 new 开头或包含 copy 的方法，或 retain 一个对象时，你将会编程它的拥有者。&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 实现 dealloc 方法，这是系统当 retain -&gt; 0 的时候，自动调用的。手动调用会引起 retain count 计数错误（多一次的 release）。 ###tableView性能优化 ####cell的循环利用方式112345678910- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; static NSString *ID = @\"cell\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleValue1 reuseIdentifier:ID]; &#125; cell.textLabel.text = @\"\"; return cell;&#125; ####cell的循环利用方式2-注册12345678910111213141516171819static NSString *ID = @\"cell\";- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.tableview.dataSource = self; self.tableview.delegate = self; [self.tableview registerClass:[UITableViewCell class] forCellReuseIdentifier:@\"cell\"];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; cell.textLabel.text = @\"\"; return cell;&#125; ###自定义cell ####等高cell1234567-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; return cell.height;&#125; ####非等高cell123456789101112131415161718192021- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; MuziCell *cell = [MuziCell cellWithTableView:tableView]; cell.status = self.statues[indexPath.row]; // 将数据传进cell [cell layoutIfNeeded]; self.heights[@(indexPath.row)] = @(cell.height); // 字典里面是对象 return cell;&#125;// 返回估计高度,非常重要，调节cellforRow和heightForRow的调用方法- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath)indexPath&#123; return 200;&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath)indexPath&#123; // 将上面的高度存起来，拿到这里使用 return [self.heights[@(indexPath.row)] doubleValue];&#125; ###设置UITableView分割线距左边的间距1234567-(void)viewDidLoad&#123;[super viewDidLoad];[self.tableView setSeparatorInset:UIEdgeInsetsZero];[self.tableView setLayoutMargins:UIEdgeInsetsZero];&#125; ####在cell将要显示出来的方法中执行下面的代码12345-(void)tableView:(UITableView )tableView willDisplayCell:(UITableViewCell )cell forRowAtIndexPath:(NSIndexPath *)indexPath&#123; [cell setSeparatorInset:UIEdgeInsetsZero]; [cell setLayoutMargins:UIEdgeInsetsZero];&#125; ###iOS隐藏导航栏正确做法 #####以往我们隐藏导航栏都是这样做：12345678- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController setNavigationBarHidden:YES animated:YES];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; #####但是往往这样 会遇到一些奇怪的 bug ，想来想去 我想到这样做可能要更好一点:123456789- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.navigationController.view sendSubviewToBack:self.navigationController.navigationBar];&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.navigationController.view bringSubviewToFront:self.navigationController.navigationBar];&#125;","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"Mac安装多个Python版本","slug":"Mac安装多个Python版本","date":"2017-08-30T01:52:58.000Z","updated":"2018-01-29T08:36:40.596Z","comments":true,"path":"2017/08/30/Mac安装多个Python版本/","link":"","permalink":"http://yoursite.com/2017/08/30/Mac安装多个Python版本/","excerpt":"","text":"######安装1brew install pyenv ######使用``` #查看当前安装的版本pyenv versions #查看当前使用的版本pyenv version #安装python3.4.2版本pyenv install -v 3.4.2 #卸载python3.4.2版本pyenv uninstall 3.4.2 #设置全局的python版本pyenv global 3.4.2 #设置面向程序的本地版本pyenv local 3.4.2 #设置面向shell的python版本pyenv shell 3.5.0 #使当前设置生效exec $SHELL #unset参数可以用于取消当前shell设定的版本pyenv shell –unset","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"使用shadowsocks加速Mac自带终端或iTerm2","slug":"使用shadowsocks加速Mac自带终端或iTerm2","date":"2017-08-30T01:52:58.000Z","updated":"2018-01-29T08:41:05.534Z","comments":true,"path":"2017/08/30/使用shadowsocks加速Mac自带终端或iTerm2/","link":"","permalink":"http://yoursite.com/2017/08/30/使用shadowsocks加速Mac自带终端或iTerm2/","excerpt":"","text":"在命令行终端中输入如下命令后，该终端即可走代理。12export http_proxy=http://127.0.0.1:1087;export https_proxy=http://127.0.0.1:1087; 注意：是当前终端标签页走代理，其他终端标签页或新窗口则不是！取消命令:12unset http_proxyunset https_proxy 如果需要代理一直生效，则可以把上述两行代码添加到 ~/.bash_profile 文件最后。12345vim ~/.bash_profile-----------------------------------------------------export http_proxy=&apos;http://127.0.0.1:1087&apos;export https_proxy=&apos;http://127.0.0.1:1087&apos;----------------------------------------------------- 使以上配置立即生效1source ~/.bash_profile 还可以在 ~/.bash_profile 里加入开关函数，使用起来更方便。1234567891011function proxy_off()&#123; unset http_proxy unset https_proxy echo -e &quot;已关闭代理&quot;&#125;function proxy_on() &#123; export no_proxy=&quot;localhost,127.0.0.1,localaddress,.localdomain.com&quot; export http_proxy=&quot;http://127.0.0.1:1087&quot; export https_proxy=$http_proxy echo -e &quot;已开启代理&quot;&#125; 测试当前终端标签/窗口是否走代理:12345➜ ~ git:(master) ✗ curl ip.gsCurrent IP / 当前 IP: 8.8.8.8ISP / 运营商: linode.comCity / 城市: Dallas TexasCountry / 国家: United States","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]}]}